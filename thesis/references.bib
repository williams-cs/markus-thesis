@article{10.1145/361011.361061,
  author     = {Ritchie, Dennis M. and Thompson, Ken},
  title      = {The UNIX Time-Sharing System},
  year       = {1974},
  issue_date = {July 1974},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {17},
  number     = {7},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/361011.361061},
  doi        = {10.1145/361011.361061},
  abstract   = {UNIX is a general-purpose, multi-user, interactive operating system for the Digital Equipment Corporation PDP-11/40 and 11/45 computers. It offers a number of features seldom found even in larger operating systems, including: (1) a hierarchical file system incorporating demountable volumes; (2) compatible file, device, and inter-process I/O; (3) the ability to initiate asynchronous processes; (4) system command language selectable on a per-user basis; and (5) over 100 subsystems including a dozen languages. This paper discusses the nature and implementation of the file system and of the user command interface.},
  journal    = {Commun. ACM},
  month      = jul,
  pages      = {365–375},
  numpages   = {11},
  keywords   = {file system, time-sharing, PDP-11, command language, operating system}
}

@article{MASSIE2004817,
  title    = {The ganglia distributed monitoring system: design, implementation, and experience},
  journal  = {Parallel Computing},
  volume   = {30},
  number   = {7},
  pages    = {817 - 840},
  year     = {2004},
  issn     = {0167-8191},
  doi      = {https://doi.org/10.1016/j.parco.2004.04.001},
  url      = {http://www.sciencedirect.com/science/article/pii/S0167819104000535},
  author   = {Matthew L Massie and Brent N Chun and David E Culler},
  keywords = {Monitoring, Clusters, Distributed systems},
  abstract = {Ganglia is a scalable distributed monitoring system for high performance computing systems such as clusters and Grids. It is based on a hierarchical design targeted at federations of clusters. It relies on a multicast-based listen/announce protocol to monitor state within clusters and uses a tree of point-to-point connections amongst representative cluster nodes to federate clusters and aggregate their state. It leverages widely used technologies such as XML for data representation, XDR for compact, portable data transport, and RRDtool for data storage and visualization. It uses carefully engineered data structures and algorithms to achieve very low per-node overheads and high concurrency. The implementation is robust, has been ported to an extensive set of operating systems and processor architectures, and is currently in use on over 500 clusters around the world. This paper presents the design, implementation, and evaluation of Ganglia along with experience gained through real world deployments on systems of widely varying scale, configurations, and target application domains over the last two and a half years.}
}

@article{10.1145/311531.311532,
  author     = {G\"{a}rtner, Felix C.},
  title      = {Fundamentals of Fault-Tolerant Distributed Computing in Asynchronous Environments},
  year       = {1999},
  issue_date = {March 1999},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {31},
  number     = {1},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/311531.311532},
  doi        = {10.1145/311531.311532},
  abstract   = {Fault tolerance in distributed computing is a wide area with a significant body of literature that is vastly diverse in methodology and terminology. This paper aims at structuring the area and thus guiding readers into this interesting field. We use a formal approach to define important terms like fault, fault tolerance, and redundancy. This leads to four distinct forms of fault tolerance and to two main phases in achieving them: detection and correction. We show that this can help to reveal inherently fundamental structures that contribute to understanding and unifying methods and terminology. By doing this, we survey many existing methodologies and discuss their relations. The underlying system model is the   close-to-reality asynchronous message-passing model of distributed computing.},
  journal    = {ACM Comput. Surv.},
  month      = mar,
  pages      = {1–26},
  numpages   = {26},
  keywords   = {liveness, agreement problem, safety, failure detection, consensus problem, fault tolerance, possibility detection, redundancy, asynchronous system, failure correction, fault models, message passing, predicate detection}
}

@article{10.1145/72551.72552,
  author     = {Bal, Henri E. and Steiner, Jennifer G. and Tanenbaum, Andrew S.},
  title      = {Programming Languages for Distributed Computing Systems},
  year       = {1989},
  issue_date = {Sep. 1989},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {21},
  number     = {3},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/72551.72552},
  doi        = {10.1145/72551.72552},
  abstract   = {When distributed systems first appeared, they were programmed in traditional sequential languages, usually with the addition of a few library procedures for sending and receiving messages. As distributed applications became more commonplace and more sophisticated, this ad hoc approach became less satisfactory. Researchers all over the world began designing new programming languages specifically for implementing distributed applications. These languages and their history, their underlying principles, their design, and their use are the subject of this paper.We begin by giving our view of what a distributed system is, illustrating with examples to avoid confusion on this important and controversial point. We then describe the three main characteristics that distinguish distributed programming languages from traditional sequential languages, namely, how they deal with parallelism, communication, and partial failures. Finally, we discuss 15 representative distributed languages to give the flavor of each. These examples include languages based on message passing, rendezvous, remote procedure call, objects, and atomic transactions, as well as functional languages, logic languages, and distributed data structure languages. The paper concludes with a comprehensive bibliography listing over 200 papers on nearly 100 distributed programming languages.},
  journal    = {ACM Comput. Surv.},
  month      = sep,
  pages      = {261–322},
  numpages   = {62}
}

@inproceedings{10.5555/1349426.1349441,
  author    = {Albrecht, Jeannie and Braud, Ryan and Dao, Darren and Topilski, Nikolay and Tuttle, Christopher and Snoeren, Alex C. and Vahdat, Amin},
  title     = {Remote Control: Distributed Application Configuration, Management, and Visualization with Plush},
  year      = {2007},
  isbn      = {9781593271527},
  publisher = {USENIX Association},
  address   = {USA},
  abstract  = {Support for distributed application management in large-scale networked environments remains in its early stages. Although a number of solutions exist for subtasks of application deployment, monitoring, maintenance, and visualization in distributed environments, few tools provide a unified framework for application management. Many of the existing tools address the management needs of a single type of application or service that runs in a specific environment, and these tools are not adaptable enough to be used for other applications or platforms. In this paper, we present the design and implementation of Plush, a fully configurable application management infrastructure designed to meet the general requirements of several different classes of distributed applications and execution environments. Plush allows developers to specifically define the flow of control needed by their computations using application building blocks. Through an extensible resource management interface, Plush supports execution in a variety of environments, including both live deployment platforms and emulated clusters. To gain an understanding of how Plush manages different classes of distributed applications, we take a closer look at specific applications and evaluate how Plush provides support for each.},
  booktitle = {Proceedings of the 21st Conference on Large Installation System Administration Conference},
  articleno = {15},
  numpages  = {19},
  location  = {Dallas},
  series    = {LISA'07}
}

@article{10.1145/210308.210315,
  author     = {Walli, Stephen R.},
  title      = {The POSIX Family of Standards},
  year       = {1995},
  issue_date = {March 1995},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {3},
  number     = {1},
  issn       = {1067-9936},
  url        = {https://doi.org/10.1145/210308.210315},
  doi        = {10.1145/210308.210315},
  journal    = {StandardView},
  month      = mar,
  pages      = {11–17},
  numpages   = {7}
}

@article{10.1145/3371111,
  author     = {Greenberg, Michael and Blatt, Austin J.},
  title      = {Executable Formal Semantics for the POSIX Shell},
  year       = {2019},
  issue_date = {January 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3371111},
  doi        = {10.1145/3371111},
  abstract   = {The POSIX shell is a widely deployed, powerful tool for managing computer systems. The shell is the expert’s control panel, a necessary tool for configuring, compiling, installing, maintaining, and deploying systems. Even though it is powerful, critical infrastructure, the POSIX shell is maligned and misunderstood. Its power and its subtlety are a dangerous combination. We define a formal, mechanized, executable small-step semantics for the POSIX shell, which we call Smoosh. We compared Smoosh against seven other shells that aim for some measure of POSIX compliance (bash, dash, zsh, OSH, mksh, ksh93, and yash). Using three test suites—the POSIX test suite, the Modernish test suite and shell diagnostic, and a test suite of our own device—we found Smoosh’s semantics to be the most conformant to the POSIX standard. Modernish judges Smoosh to have the fewest bugs (just one, from using dash’s parser) and no quirks. To show that our semantics is useful beyond yielding a conformant, executable shell, we also implemented a symbolic stepper to illuminate the subtle behavior of the shell. Smoosh will serve as a foundation for formal study of the POSIX shell, supporting research on and development of new shells, new tooling for shells, and new shell designs.},
  journal    = {Proc. ACM Program. Lang.},
  month      = dec,
  articleno  = {43},
  numpages   = {30},
  keywords   = {small-step semantics, formalization, command line interfaces, POSIX}
}

@article{1702415,
  author  = {Leslie Lamport},
  journal = {IEEE Transactions on Software Engineering},
  title   = {Proving the Correctness of Multiprocess Programs},
  year    = {1977},
  volume  = {SE-3},
  number  = {2},
  pages   = {125-143},
  doi     = {10.1109/TSE.1977.229904}
}

@inproceedings{dean2004mapreduce,
  title     = {MapReduce: Simplified Data Processing on Large Clusters},
  author    = {Jeffrey Dean and Sanjay Ghemawat},
  year      = {2004},
  booktitle = {OSDI'04: Sixth Symposium on Operating System Design and Implementation},
  pages     = {137--150},
  address   = {San Francisco, CA}
}

@misc{rfc4251,
  series       = {Request for Comments},
  number       = {4251},
  howpublished = {RFC 4251},
  publisher    = {RFC Editor},
  doi          = {10.17487/RFC4251},
  url          = {https://rfc-editor.org/rfc/rfc4251.txt},
  author       = {T. Ylonen},
  title        = {The Secure Shell (SSH) Protocol Architecture},
  year         = {2006},
  month        = {Jan.},
  abstract     = {The Secure Shell (SSH) Protocol is a protocol for secure remote login and other secure network services over an insecure network.  This document describes the architecture of the SSH protocol, as well as the notation and terminology used in SSH protocol documents.  It also discusses the SSH algorithm naming system that allows local extensions.  The SSH protocol consists of three major components: The Transport Layer Protocol provides server authentication, confidentiality, and integrity with perfect forward secrecy.  The User Authentication Protocol authenticates the client to the server. The Connection Protocol multiplexes the encrypted tunnel into several logical channels.  Details of these protocols are described in separate documents.}
}

@misc{posix2017,
  title        = {POSIX.1 2017},
  author       = {{The Open Group}},
  howpublished = {\url{https://pubs.opengroup.org/onlinepubs/9699919799/mindex.html}},
  year         = {2018},
  note         = {Accessed: 2020-12-14}
}
  
@misc{borthakur2007hadoop,
  title        = {The hadoop distributed file system: Architecture and design},
  author       = {Borthakur, Dhruba},
  howpublished = {\url{http://svn.apache.org/repos/asf/hadoop/common/tags/release-0.16.1/docs/hdfs_design.pdf}},
  year         = {2007},
  note         = {Accessed: 2020-12-14}
}

@misc{bretthauer2001open,
  title        = {Open source software: A history},
  author       = {Bretthauer, David},
  howpublished = {\url{https://opencommons.uconn.edu/libr_pubs/7}},
  year         = {2001},
  note         = {Accessed: 2020-12-14}
}

@misc{Hadoop,
  title        = {Apache Hadoop},
  author       = {{The Apache Software Foundation}},
  howpublished = {\url{https://hadoop.apache.org/}},
  note         = {Accessed: 2020-12-14}
}

@misc{gexec,
  author       = {Brent N. Chun},
  title        = {GEXEC},
  howpublished = {\url{http://www.theether.org/gexec/}},
  note         = {Accessed: 2020-12-14}
}

@misc{dshdancer,
  author       = {Junichi Uekawa},
  title        = {DSH - dancer's shell / distributed shell},
  howpublished = {\url{https://www.netfort.gr.jp/~dancer/software/dsh.html.en}},
  note         = {Accessed: 2020-12-14}
}

@misc{distsh,
  author       = {Fried, Limor and Tibbetts, Richard},
  title        = {Distributed Command Line Interface},
  year         = {2001},
  howpublished = {\url{https://pdos.csail.mit.edu/archive/6.824-2001/projects/paper-3.ps}},
  note         = {Accessed: 2020-12-14}
}

@article{armstrong2010erlang,
  title     = {Erlang},
  author    = {Armstrong, Joe},
  journal   = {Communications of the ACM},
  volume    = {53},
  number    = {9},
  pages     = {68--75},
  year      = {2010},
  publisher = {ACM New York, NY, USA}
}

@article{mccarthy1960recursive,
  title     = {Recursive functions of symbolic expressions and their computation by machine, part I},
  author    = {McCarthy, John},
  journal   = {Communications of the ACM},
  volume    = {3},
  number    = {4},
  pages     = {184--195},
  year      = {1960},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{dolan2014multicore,
  title     = {Multicore ocaml},
  author    = {Dolan, Stephen and White, Leo and Madhavapeddy, Anil},
  booktitle = {OCaml Workshop},
  volume    = {2},
  year      = {2014}
}

@article{sivaramakrishnan2020retrofitting,
  title     = {Retrofitting parallelism onto OCaml},
  author    = {Sivaramakrishnan, KC and Dolan, Stephen and White, Leo and Jaffer, Sadiq and Kelly, Tom and Sahoo, Anmol and Parimala, Sudha and Dhiman, Atul and Madhavapeddy, Anil},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {4},
  number    = {ICFP},
  pages     = {1--30},
  year      = {2020},
  publisher = {ACM New York, NY, USA}
}

@article{chung2003generalizations,
  title     = {Generalizations of Polya's urn problem},
  author    = {Chung, Fan and Handjani, Shirin and Jungreis, Doug},
  journal   = {Annals of combinatorics},
  volume    = {7},
  number    = {2},
  pages     = {141--153},
  year      = {2003},
  publisher = {Springer}
}

@misc{ocamlcore,
  author       = {{Jane Street Group LLC}},
  title        = {Core --- A fully featured alternative standard library for OCaml},
  howpublished = {\url{https://opensource.janestreet.com/core/}},
  note         = {Accessed: 2021-04-22}
}

@misc{ocamlasync,
  author       = {{Jane Street Group LLC}},
  title        = {Async --- Typeful concurrent programming},
  howpublished = {\url{https://opensource.janestreet.com/async/}},
  note         = {Accessed: 2021-04-22}
}

@misc{ocamlangstrom,
  author       = {{Inhabited Type LLC}},
  title        = {Angstrom},
  howpublished = {\url{https://github.com/inhabitedtype/angstrom}},
  note         = {Accessed: 2021-04-22}
}

@misc{libssh,
  key          = {Libssh},
  title        = {Libssh --- The SSH library},
  howpublished = {\url{https://www.libssh.org/}},
  note         = {Accessed: 2021-04-22}
}

@misc{mllibssh,
  author       = {Pino Toscano},
  title        = {mllibssh},
  howpublished = {\url{https://gitlab.com/pinotree/mllibssh}},
  note         = {Accessed: 2021-04-22}
}

@book{realworldocaml,
  title     = {Real World OCaml: Functional programming for the masses},
  author    = {Minsky, Yaron and Madhavapeddy, Anil and Hickey, Jason},
  year      = {2021},
  edition   = {2nd},
  publisher = {O'Reilly Media, Inc.},
  note      = {\url{https://dev.realworldocaml.org/index.html}}
}

@misc{openssh,
  author       = {{OpenBSD Project}},
  title        = {OpenSSH --- Keeping your communiqu\'es secret},
  howpublished = {\url{https://www.openssh.com/}},
  note         = {Accessed: 2021-04-22}
}

@book{hamlet,
  author    = {William Shakespeare},
  title     = {Hamlet},
  publisher = {Project Gutenberg},
  year      = {1998},
  note      = {\url{https://www.gutenberg.org/files/1524/1524-h/1524-h.htm}}
}
