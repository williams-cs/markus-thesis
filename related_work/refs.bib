@inproceedings{10.5555/1785080.1785082,
author = {Rellermeyer, Jan S. and Alonso, Gustavo and Roscoe, Timothy},
title = {{R-OSGi: Distributed Applications through Software Modularization}},
year = {2007},
isbn = {3540767770},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {In this paper we take advantage of the concepts developed for centralized module management, such as dynamic loading and unloading of modules, and show how they can be used to support the development and deployment of distributed applications. We do so through R-OSGi, a distributed middleware platform that extends the centralized, industry-standard OSGi specification to support distributed module management. To the developer, R-OSGi looks like a conventional module management tool. However, at deployment time, R-OSGi can be used to turn the application into a distributed application by simply indicating where the different modules should be deployed. At run time, R-OSGi represents distributed failures as module insertion and withdrawal operations so that the logic to deal with failures is the same as that employed to deal with dependencies among software modules. In doing so, R-OSGi greatly simplifies the development of distributed applications with no performance cost. In the paper we describe R-OSGi and several use cases. We also show with extensive experiments that R-OSGi has a performance comparable or better than that of RMI or UPnP, both commonly used distribution mechanisms with far less functionality than R-OSGi.},
booktitle = {Proceedings of the 8th ACM/IFIP/USENIX International Conference on Middleware},
pages = {1–20},
numpages = {20},
location = {Newport Beach, CA, USA},
series = {MIDDLEWARE2007}
}

@inproceedings{10.1145/1328279.1328290,
author = {Rellermeyer, Jan S. and Alonso, Gustavo and Roscoe, Timothy},
title = {{Building, Deploying, and Monitoring Distributed Applications with Eclipse and R-OSGI}},
year = {2007},
isbn = {9781605580159},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1328279.1328290},
doi = {10.1145/1328279.1328290},
abstract = {Designing and testing distributed applications is still a difficult task that requires in-depth knowledge about networking issues. Eclipse is, among other things, a powerful and widely used IDE for the development of complex applications, in particular modular applications for the OSGi framework. Our R-OSGi middleware supports the seamless distribution of OSGi applications along the boundaries of services. By combining R-OSGi with Eclipse into the R-OSGi Deployment Tool, we give developers a tool that automatically handles distribution in a transparent way and integrates the capabilities of R-OSGi into the Eclipse workflow. With this tool, building, deploying, and monitoring distributed applications is as easy as writing OSGi applications in Eclipse and using a graphical editor to visually create distributed deployments of the modules. The tool can also be used to great effect by researchers to test and benchmark distributed applications and for education purposes.},
booktitle = {Proceedings of the 2007 OOPSLA Workshop on Eclipse Technology EXchange},
pages = {50–54},
numpages = {5},
keywords = {R-OSGi, OSGi, concierge, deployment, Eclipse},
location = {Montreal, Quebec, Canada},
series = {eclipse '07}
}

@article{10.1109/2.53354,
author = {Mullender, Sape J. and van Rossum, Guido and Tanenbaum, Andrew S. and van Renesse, Robbert and van Staveren, Hans},
title = {{Amoeba: A Distributed Operating System for the 1990s}},
year = {1990},
issue_date = {May 1990},
publisher = {IEEE Computer Society Press},
address = {Washington, DC, USA},
volume = {23},
number = {5},
issn = {0018-9162},
url = {https://doi.org/10.1109/2.53354},
doi = {10.1109/2.53354},
abstract = {A description is given of the Amoeba distributed operating system, which appears to users as a centralized system but has the speed, fault tolerance, security safeguards, and flexibility required for the 1990s. The Amoeba software is based on objects. Objects are managed by server processes and named using capabilities chosen randomly from a sparse name space. Amoeba has a unique, fast file system split into two parts: the bullet service stores immutable files contiguously on the disk; the directory service gives capabilities symbolic names and handles replication and atomicity, eliminating the need for a separate transaction management system. To bridge the gap with existing systems, Amoeba has a Unix emulation facility consisting of a library of Unix system call routines that make calls to the various Amoeba server processes.},
journal = {Computer},
month = may,
pages = {44–53},
numpages = {10}
}

@article{DBLP:journals/csys/PikePDFTT95,
  author    = {Rob Pike and
               David L. Presotto and
               Sean Dorward and
               Bob Flandrena and
               Ken Thompson and
               Howard Trickey and
               Phil Winterbottom},
  title     = {{Plan 9 from Bell Labs}},
  journal   = {Comput. Syst.},
  volume    = {8},
  number    = {2},
  pages     = {221--254},
  year      = {1995},
  url       = {http://www.usenix.org/publications/compsystems/1995/sum\_pike.pdf},
  timestamp = {Sun, 10 May 2020 21:17:35 +0200},
  biburl    = {https://dblp.org/rec/journals/csys/PikePDFTT95.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{10.5555/1267569.1267573,
author = {Yl\"{o}nen, Tatu},
title = {{SSH: Secure Login Connections over the Internet}},
year = {1996},
publisher = {USENIX Association},
address = {USA},
abstract = {SSH provides secure login, file transfer, X11, and TCP/IP connections over an untrusted network. It uses cryptographic authentication, automatic session encryption, and integrity protection for transferred data. RSA is used for key exchange and authentication, and symmetric algorithms (e.g., IDEA or three-key triple-DES) for encrypting transferred data.SSH is intended as a replacement for the existing rsh, rlogin, rcp, rdist, and telnet protocols. SSH is currently (March 1996) being used at thousands of sites in at least 50 countries. Its users include top universities, research laboratories, many major corporations, and numerous smaller companies and individuals.The SSH protocol can also be used as a generic transport layer encryption mechanism, providing both host authentication and user authentication, together with privacy and integrity protection.},
booktitle = {Proceedings of the 6th Conference on USENIX Security Symposium, Focusing on Applications of Cryptography - Volume 6},
pages = {4},
numpages = {1},
location = {San Jose, California},
series = {SSYM'96}
}

@inproceedings{10.5555/2002181.2002202,
author = {Guo, Philip J. and Engler, Dawson},
title = {CDE: Using System Call Interposition to Automatically Create Portable Software Packages},
year = {2011},
publisher = {USENIX Association},
address = {USA},
abstract = {It can be painfully hard to take software that runs on one person's machine and get it to run on another machine. Online forums and mailing lists are filled with discussions of users' troubles with compiling, installing, and configuring software and their myriad of dependencies. To eliminate this dependency problem, we created a system called CDE that uses system call interposition to monitor the execution of x86-Linux programs and package up the Code, Data, and Environment required to run them on other x86-Linux machines. Creating a CDE package is completely automatic, and running programs within a package requires no installation, configuration, or root permissions. Hundreds of people in both academia and industry have used CDE to distribute software, demo prototypes, make their scientific experiments reproducible, run software natively on older Linux distributions, and deploy experiments to compute clusters.},
booktitle = {Proceedings of the 2011 USENIX Conference on USENIX Annual Technical Conference},
pages = {21},
numpages = {1},
location = {Portland, OR},
series = {USENIXATC'11}
}

@article{10.1109/MCSE.2012.36,
author = {Guo, Philip},
title = {CDE: A Tool for Creating Portable Experimental Software Packages},
year = {2012},
issue_date = {July 2012},
publisher = {IEEE Educational Activities Department},
address = {USA},
volume = {14},
number = {4},
issn = {1521-9615},
url = {https://doi.org/10.1109/MCSE.2012.36},
doi = {10.1109/MCSE.2012.36},
abstract = {One technical barrier to reproducible computational science is that it's hard to distribute scientific code in a form that other researchers can easily execute on their own computers. To help eliminate this barrier, the CDE tool packages all software dependencies required to rerun Linux-based computational experiments on other computers.},
journal = {Computing in Science and Engg.},
month = jul,
pages = {32–35},
numpages = {4},
keywords = {maintenance, Scientific computing, Reproducibility of results, configuration management, Computational modeling, portability, software engineering, Research and development, Software engineering, Linux, scientific computing, software release management and delivery, distribution, Maintenance engineering, and enhancement}
}

@inproceedings {180748,
author = {Fernando Chirigati and Dennis Shasha and Juliana Freire},
title = {ReproZip: Using Provenance to Support Computational Reproducibility },
booktitle = {5th {USENIX} Workshop on the Theory and Practice of Provenance (TaPP 13)},
year = {2013},
address = {Lombard, IL},
url = {https://www.usenix.org/conference/tapp13/technical-sessions/presentation/chirigati},
publisher = {{USENIX} Association},
month = apr,
}

@inproceedings{10.1145/1341811.1341824,
author = {Rapier, Chris and Bennett, Benjamin},
title = {High Speed Bulk Data Transfer Using the SSH Protocol},
year = {2008},
isbn = {9781595938350},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1341811.1341824},
doi = {10.1145/1341811.1341824},
abstract = {SSH is a highly successful multipurpose protocol used for both interactive shells and transport layer mechanisms. However, a design choice in most implementations of SSH reduces its functionality as bulk data transport tool in high performance network environments. This paper will discuss the nature of this limitation, the functional barriers it imposes, a method by which it can be remedied, and introduces a high performance implementation based on the industry standard, OpenSSH. Additionally, the authors will introduce a method by which performance on multi-core systems is improved through the use of cipher multi-threading.},
booktitle = {Proceedings of the 15th ACM Mardi Gras Conference: From Lightweight Mash-Ups to Lambda Grids: Understanding the Spectrum of Distributed Computing Requirements, Applications, Tools, Infrastructures, Interoperability, and the Incremental Adoption of Key Capabilities},
articleno = {11},
numpages = {7},
keywords = {high performance networks, SSH, buffers, auto-tuning, HPN, HPN-SSH, security, performance, bottlenecks, cryptography},
location = {Baton Rouge, Louisiana, USA},
series = {MG '08}
}

@article{MASSIE2004817,
title = "The ganglia distributed monitoring system: design, implementation, and experience",
journal = "Parallel Computing",
volume = "30",
number = "7",
pages = "817 - 840",
year = "2004",
issn = "0167-8191",
doi = "https://doi.org/10.1016/j.parco.2004.04.001",
url = "http://www.sciencedirect.com/science/article/pii/S0167819104000535",
author = "Matthew L Massie and Brent N Chun and David E Culler",
keywords = "Monitoring, Clusters, Distributed systems",
abstract = "Ganglia is a scalable distributed monitoring system for high performance computing systems such as clusters and Grids. It is based on a hierarchical design targeted at federations of clusters. It relies on a multicast-based listen/announce protocol to monitor state within clusters and uses a tree of point-to-point connections amongst representative cluster nodes to federate clusters and aggregate their state. It leverages widely used technologies such as XML for data representation, XDR for compact, portable data transport, and RRDtool for data storage and visualization. It uses carefully engineered data structures and algorithms to achieve very low per-node overheads and high concurrency. The implementation is robust, has been ported to an extensive set of operating systems and processor architectures, and is currently in use on over 500 clusters around the world. This paper presents the design, implementation, and evaluation of Ganglia along with experience gained through real world deployments on systems of widely varying scale, configurations, and target application domains over the last two and a half years."
}

@inproceedings{10.1145/2442516.2442559,
author = {Wozniak, Justin M. and Armstrong, Timothy G. and Wilde, Michael and Katz, Daniel S. and Lusk, Ewing and Foster, Ian T.},
title = {Swift/T: Scalable Data Flow Programming for Many-Task Applications},
year = {2013},
isbn = {9781450319225},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2442516.2442559},
doi = {10.1145/2442516.2442559},
abstract = {Swift/T, a novel programming language implementation for highly scalable data flow programs, is presented.},
booktitle = {Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {309–310},
numpages = {2},
keywords = {concurrency, futures, adlb, swift, dataflow, exascale, turbine, mpi},
location = {Shenzhen, China},
series = {PPoPP '13}
}


@article{WILDE2011633,
title = "Swift: A language for distributed parallel scripting",
journal = "Parallel Computing",
volume = "37",
number = "9",
pages = "633 - 652",
year = "2011",
note = "Emerging Programming Paradigms for Large-Scale Scientific Computing",
issn = "0167-8191",
doi = "https://doi.org/10.1016/j.parco.2011.05.005",
url = "http://www.sciencedirect.com/science/article/pii/S0167819111000524",
author = "Michael Wilde and Mihael Hategan and Justin M. Wozniak and Ben Clifford and Daniel S. Katz and Ian Foster",
keywords = "Swift, Parallel programming, Scripting, Dataflow",
abstract = "Scientists, engineers, and statisticians must execute domain-specific application programs many times on large collections of file-based data. This activity requires complex orchestration and data management as data is passed to, from, and among application invocations. Distributed and parallel computing resources can accelerate such processing, but their use further increases programming complexity. The Swift parallel scripting language reduces these complexities by making file system structures accessible via language constructs and by allowing ordinary application programs to be composed into powerful parallel scripts that can efficiently utilize parallel and distributed resources. We present Swift’s implicitly parallel and deterministic programming model, which applies external applications to file collections using a functional style that abstracts and simplifies distributed parallel execution."
}

@article{10.1145/3371111,
author = {Greenberg, Michael and Blatt, Austin J.},
title = {Executable Formal Semantics for the POSIX Shell},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371111},
doi = {10.1145/3371111},
abstract = {The POSIX shell is a widely deployed, powerful tool for managing computer systems. The shell is the expert’s control panel, a necessary tool for configuring, compiling, installing, maintaining, and deploying systems. Even though it is powerful, critical infrastructure, the POSIX shell is maligned and misunderstood. Its power and its subtlety are a dangerous combination. We define a formal, mechanized, executable small-step semantics for the POSIX shell, which we call Smoosh. We compared Smoosh against seven other shells that aim for some measure of POSIX compliance (bash, dash, zsh, OSH, mksh, ksh93, and yash). Using three test suites—the POSIX test suite, the Modernish test suite and shell diagnostic, and a test suite of our own device—we found Smoosh’s semantics to be the most conformant to the POSIX standard. Modernish judges Smoosh to have the fewest bugs (just one, from using dash’s parser) and no quirks. To show that our semantics is useful beyond yielding a conformant, executable shell, we also implemented a symbolic stepper to illuminate the subtle behavior of the shell. Smoosh will serve as a foundation for formal study of the POSIX shell, supporting research on and development of new shells, new tooling for shells, and new shell designs.},
journal = {Proc. ACM Program. Lang.},
month = dec,
articleno = {43},
numpages = {30},
keywords = {small-step semantics, formalization, command line interfaces, POSIX}
}

@inproceedings{10.1145/1645164.1645175,
author = {Walker, Edward and Xu, Weijia and Chandar, Vinoth},
title = {Composing and Executing Parallel Data-Flow Graphs with Shell Pipes},
year = {2009},
isbn = {9781605587172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1645164.1645175},
doi = {10.1145/1645164.1645175},
abstract = {In this paper we extend the concept of shell pipes to incorporate forks, joins, cycles, and key-value aggregation. These extensions enable the implementation of a class of data-flow computation with strong deterministic properties, and provide a simple yet powerful coordination layer for leveraging multi-language and legacy components for large-scale parallel computation. Concretely, this paper describes the design and implementation of the language extensions in Bourne Again SHell (BASH), and examines the performance of the system using micro and macro benchmarks. The implemented system is shown to scale to thousands of processors, enabling high throughput performance for millions of processing tasks on large commodity compute clusters.},
booktitle = {Proceedings of the 4th Workshop on Workflows in Support of Large-Scale Science},
articleno = {11},
numpages = {10},
keywords = {data-flow processing, parallel processing, coordination languages},
location = {Portland, Oregon},
series = {WORKS '09}
}

@article{article,
author = {Spinellis, Diomidis and Fragkoulis, Marios},
year = {2017},
month = {04},
pages = {1-1},
title = {Extending Unix Pipelines to DAGs},
volume = {PP},
journal = {IEEE Transactions on Computers},
doi = {10.1109/TC.2017.2695447}
}
@article{10.1145/361011.361061,
author = {Ritchie, Dennis M. and Thompson, Ken},
title = {The UNIX Time-Sharing System},
year = {1974},
issue_date = {July 1974},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/361011.361061},
doi = {10.1145/361011.361061},
abstract = {UNIX is a general-purpose, multi-user, interactive operating system for the Digital Equipment Corporation PDP-11/40 and 11/45 computers. It offers a number of features seldom found even in larger operating systems, including: (1) a hierarchical file system incorporating demountable volumes; (2) compatible file, device, and inter-process I/O; (3) the ability to initiate asynchronous processes; (4) system command language selectable on a per-user basis; and (5) over 100 subsystems including a dozen languages. This paper discusses the nature and implementation of the file system and of the user command interface.},
journal = {Commun. ACM},
month = jul,
pages = {365–375},
numpages = {11},
keywords = {file system, time-sharing, PDP-11, command language, operating system}
}
@article{MASSIE2004817,
title = "The ganglia distributed monitoring system: design, implementation, and experience",
journal = "Parallel Computing",
volume = "30",
number = "7",
pages = "817 - 840",
year = "2004",
issn = "0167-8191",
doi = "https://doi.org/10.1016/j.parco.2004.04.001",
url = "http://www.sciencedirect.com/science/article/pii/S0167819104000535",
author = "Matthew L Massie and Brent N Chun and David E Culler",
keywords = "Monitoring, Clusters, Distributed systems",
abstract = "Ganglia is a scalable distributed monitoring system for high performance computing systems such as clusters and Grids. It is based on a hierarchical design targeted at federations of clusters. It relies on a multicast-based listen/announce protocol to monitor state within clusters and uses a tree of point-to-point connections amongst representative cluster nodes to federate clusters and aggregate their state. It leverages widely used technologies such as XML for data representation, XDR for compact, portable data transport, and RRDtool for data storage and visualization. It uses carefully engineered data structures and algorithms to achieve very low per-node overheads and high concurrency. The implementation is robust, has been ported to an extensive set of operating systems and processor architectures, and is currently in use on over 500 clusters around the world. This paper presents the design, implementation, and evaluation of Ganglia along with experience gained through real world deployments on systems of widely varying scale, configurations, and target application domains over the last two and a half years."
}
@article{10.1145/311531.311532,
author = {G\"{a}rtner, Felix C.},
title = {Fundamentals of Fault-Tolerant Distributed Computing in Asynchronous Environments},
year = {1999},
issue_date = {March 1999},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {31},
number = {1},
issn = {0360-0300},
url = {https://doi.org/10.1145/311531.311532},
doi = {10.1145/311531.311532},
abstract = {Fault tolerance in distributed computing is a wide area with a significant body of literature that is vastly diverse in methodology and terminology. This paper aims at structuring the area and thus guiding readers into this interesting field. We use a formal approach to define important terms like fault, fault tolerance, and redundancy. This leads to four distinct forms of fault tolerance and to two main phases in achieving them: detection and correction. We show that this can help to reveal inherently fundamental structures that contribute to understanding and unifying methods and terminology. By doing this, we survey many existing methodologies and discuss their relations. The underlying system model is the   close-to-reality asynchronous message-passing model of distributed computing.},
journal = {ACM Comput. Surv.},
month = mar,
pages = {1–26},
numpages = {26},
keywords = {liveness, agreement problem, safety, failure detection, consensus problem, fault tolerance, possibility detection, redundancy, asynchronous system, failure correction, fault models, message passing, predicate detection}
}

@article{10.1145/72551.72552,
author = {Bal, Henri E. and Steiner, Jennifer G. and Tanenbaum, Andrew S.},
title = {Programming Languages for Distributed Computing Systems},
year = {1989},
issue_date = {Sep. 1989},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {3},
issn = {0360-0300},
url = {https://doi.org/10.1145/72551.72552},
doi = {10.1145/72551.72552},
abstract = {When distributed systems first appeared, they were programmed in traditional sequential languages, usually with the addition of a few library procedures for sending and receiving messages. As distributed applications became more commonplace and more sophisticated, this ad hoc approach became less satisfactory. Researchers all over the world began designing new programming languages specifically for implementing distributed applications. These languages and their history, their underlying principles, their design, and their use are the subject of this paper.We begin by giving our view of what a distributed system is, illustrating with examples to avoid confusion on this important and controversial point. We then describe the three main characteristics that distinguish distributed programming languages from traditional sequential languages, namely, how they deal with parallelism, communication, and partial failures. Finally, we discuss 15 representative distributed languages to give the flavor of each. These examples include languages based on message passing, rendezvous, remote procedure call, objects, and atomic transactions, as well as functional languages, logic languages, and distributed data structure languages. The paper concludes with a comprehensive bibliography listing over 200 papers on nearly 100 distributed programming languages.},
journal = {ACM Comput. Surv.},
month = sep,
pages = {261–322},
numpages = {62}
}

@article{dean2004mapreduce,
  title={MapReduce: Simplified data processing on large clusters},
  author={Dean, Jeffrey and Ghemawat, Sanjay},
  year={2004}
}

@inproceedings{10.5555/1349426.1349441,
author = {Albrecht, Jeannie and Braud, Ryan and Dao, Darren and Topilski, Nikolay and Tuttle, Christopher and Snoeren, Alex C. and Vahdat, Amin},
title = {Remote Control: Distributed Application Configuration, Management, and Visualization with Plush},
year = {2007},
isbn = {9781593271527},
publisher = {USENIX Association},
address = {USA},
abstract = {Support for distributed application management in large-scale networked environments remains in its early stages. Although a number of solutions exist for subtasks of application deployment, monitoring, maintenance, and visualization in distributed environments, few tools provide a unified framework for application management. Many of the existing tools address the management needs of a single type of application or service that runs in a specific environment, and these tools are not adaptable enough to be used for other applications or platforms. In this paper, we present the design and implementation of Plush, a fully configurable application management infrastructure designed to meet the general requirements of several different classes of distributed applications and execution environments. Plush allows developers to specifically define the flow of control needed by their computations using application building blocks. Through an extensible resource management interface, Plush supports execution in a variety of environments, including both live deployment platforms and emulated clusters. To gain an understanding of how Plush manages different classes of distributed applications, we take a closer look at specific applications and evaluate how Plush provides support for each.},
booktitle = {Proceedings of the 21st Conference on Large Installation System Administration Conference},
articleno = {15},
numpages = {19},
location = {Dallas},
series = {LISA'07}
}

@article{10.1145/210308.210315,
author = {Walli, Stephen R.},
title = {The POSIX Family of Standards},
year = {1995},
issue_date = {March 1995},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {1},
issn = {1067-9936},
url = {https://doi.org/10.1145/210308.210315},
doi = {10.1145/210308.210315},
journal = {StandardView},
month = mar,
pages = {11–17},
numpages = {7}
}

@ARTICLE{1702415,

  author={L. {Lamport}},

  journal={IEEE Transactions on Software Engineering}, 

  title={Proving the Correctness of Multiprocess Programs}, 

  year={1977},

  volume={SE-3},

  number={2},

  pages={125-143},

  doi={10.1109/TSE.1977.229904}}
